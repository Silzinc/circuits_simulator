fn test_() -> crate::error::Result<()>
{
  // Emulate a serial RLC circuit with a square wave of period
  // 4 ms that starts after 2 ms as input
  use crate::{
    Circuit, Component,
    Dipole::{Capacitor, Inductor, Resistor},
  };
  use plotters::prelude::*;
  use std::{env, time::Instant};

  fn square_wave(x: f64) -> f64
  {
    if x < 2e-3 {
      0.
    } else if ((x + 2e-3) % 4e-3) > 2e-3 {
      -1.
    } else {
      1.
    }
  }

  let n_freqs = 1000;
  let duration = 10e-3;
  let step = duration / n_freqs as f64;

  // Create the serial RLC circuit
  let mut c = Circuit::new();
  c.set_generator_fn(square_wave, duration, n_freqs);
  c.content
    .push_serie(Component::from(Resistor(200.))) // 0.2 kΩ, at position [0]
    .push_serie(Component::from(Capacitor(10e-9))) // 10 nF at position [1]
    .push_serie(Component::from(Inductor(100e-3))); // 100 mH at position [2]

  // With this, the attenuation time is 500 µs
  // and the pseudo-period is close to 200 µs

  // Simulate the circuit
  let start = Instant::now();
  let result = c.emulate_many(duration, step, &vec![vec![], vec![1u8]])?;
  let time_required = start.elapsed().as_secs_f64();
  println!("Time required to emulate the circuit: {}s", time_required);

  let tensions1 = &result[0].1; // Tension generated by the source (because of Kirchhoff's voltage law)
  let tensions2 = &result[1].1; // Tension felt by the capacitor
  let time_array: Vec<f64> = (0..tensions1.len()).map(|i| i as f64 * step).collect();

  // Save the results to a file
  env::set_current_dir(env!("CARGO_MANIFEST_DIR")).expect("Failed to set current dir");
  let out_path = env::current_dir()?.join("out").join("tensions.png");

  // Plot the results
  let root = BitMapBackend::new(&out_path, (800, 600)).into_drawing_area();
  root.fill(&WHITE).expect("Failed to fill the drawing area");
  let mut chart = ChartBuilder::on(&root)
    .caption("Tensions", ("sans-serif", 20).into_font())
    .margin(5)
    .x_label_area_size(40)
    .y_label_area_size(40)
    .build_cartesian_2d(0f64..duration, -3f64..3f64)
    .expect("Failed to build the chart");

  chart
    .configure_mesh()
    .draw()
    .expect("Failed to draw the mesh");
  chart
    .draw_series(LineSeries::new(
      time_array
        .iter()
        .zip(tensions1.iter())
        .map(|(x, y)| (*x, *y)),
      &RED,
    ))
    .expect("Failed to draw the source's tensions")
    .label("Tension generated by the source")
    .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &RED));
  chart
    .draw_series(LineSeries::new(
      time_array
        .iter()
        .zip(tensions2.iter())
        .map(|(x, y)| (*x, *y)),
      &BLUE,
    ))
    .expect("Failed to draw the capacitor's tensions")
    .label("Tension felt by the capacitor")
    .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &BLUE));
  chart
    .configure_series_labels()
    .background_style(&WHITE.mix(0.8))
    .border_style(&BLACK)
    .draw()
    .expect("Failed to draw the series labels");

  root.present().expect("Failed to save the plot");

  Ok(())
}

#[test]
fn test()
{
  if let Err(e) = test_() {
    panic!("{}", e);
  }
}
